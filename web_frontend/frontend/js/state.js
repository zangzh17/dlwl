/**
 * Application State Management
 */

const AppState = {
    // Current step in workflow
    currentStep: 'configure',

    // Wizard input (for generating structured params)
    // Only contains fields needed for pattern generation
    wizardInput: {
        doe_type: 'splitter_2d',
        wavelength: 532e-9,
        device_diameter: 256e-6,
        pixel_size: 1e-6,
        target_spec: {
            num_spots: [5, 5],
            target_type: 'angle',
            target_span: [0.1, 0.1],
            grid_mode: 'natural',
            tolerance: 0.05
        },
        working_distance: null
    },

    // Structured Parameters (directly editable, decoupled from wizard)
    // refraction_index removed - backend uses default 1.62
    structuredParams: {
        propagation_type: 'fft',
        working_distance: null,
        target_span: null,  // Physical target span for ASM/SFR (meters)
        wavelength: 532e-9,
        pixel_size: 1e-6,
        doe_pixels: [256, 256],
        simulation_pixels: [21, 21],
        period_pixels: 21,
        num_periods: [12, 12]
    },

    // Target pattern (generated by wizard, stored here for Preview/Optimization)
    targetPattern: null,

    // Reference values (read-only, computed)
    referenceValues: {
        tolerance_limit: null,
        max_diffraction_angle: null,
        period_meters: null,
        strategy: null
    },

    // Advanced settings
    advancedSettings: {
        max_resolution: 2000,
        target_margin: 10,  // percent
        progress_interval: 50
    },

    // Optimization settings
    optimizationSettings: {
        phase_method: 'SGD',
        phase_lr: 3e-9,
        phase_iters: 1000,
        loss_type: 'L2',
        simulation_upsample: 1,
        pixel_multiplier: 1
    },

    // Generated data from wizard
    propagatorConfig: null,
    computedValues: null,
    warnings: [],
    metadata: null,

    // Preview data
    geometrySvg: null,
    targetScatter: null,
    targetHeatmap: null,

    // Optimization state
    taskId: null,
    progress: null,
    lossHistory: [],
    isOptimizing: false,

    // WebSocket connection
    ws: null,

    // Results
    result: null,
    visualization: null,

    /**
     * Update state with new values
     * @param {Object} updates - Key-value pairs to update
     */
    update(updates) {
        Object.assign(this, updates);
    },

    /**
     * Determine propagation type for finite distance based on target span and DOE size
     */
    determineFiniteDistancePropType() {
        const wizard = this.wizardInput;
        const targetSpec = wizard.target_spec;
        const maxResolution = this.advancedSettings.max_resolution || 2000;

        // Get target span in meters
        let targetSpan;
        if (Array.isArray(targetSpec.target_span)) {
            targetSpan = Math.max(...targetSpec.target_span);
        } else {
            targetSpan = targetSpec.target_span;
        }

        // If target_type is 'angle', target_span is in radians - convert to physical size at working distance
        if (targetSpec.target_type === 'angle' && wizard.working_distance) {
            targetSpan = 2 * wizard.working_distance * Math.tan(targetSpan / 2);
        }

        const doeDiameter = wizard.device_diameter;
        const pixelSize = wizard.pixel_size;

        // Calculate target pixels at DOE pixel resolution
        const targetPixels = Math.ceil(targetSpan / pixelSize);

        // Decision logic:
        // 1. Target Span <= DOE diameter: use ASM (crop result)
        // 2. Target Span > DOE diameter but targetPixels < maxResolution: use ASM with padding
        // 3. Target Span > DOE diameter and targetPixels >= maxResolution: use SFR
        if (targetSpan <= doeDiameter) {
            return { propType: 'asm', strategy: 'crop' };
        } else if (targetPixels < maxResolution) {
            return { propType: 'asm', strategy: 'padding' };
        } else {
            return { propType: 'sfr', strategy: 'sfr' };
        }
    },

    /**
     * Update structured params from wizard output
     */
    updateFromWizard(wizardOutput) {
        const params = wizardOutput.structured_params || {};
        const config = wizardOutput.propagator_config || {};
        const computed = wizardOutput.computed_values || {};

        // Determine propagation type based on wizard input
        let propType = config.propagation_type || params.propagation_type || 'fft';
        let finiteStrategy = null;

        // If finite distance is specified, set appropriate propagation type
        if (this.wizardInput.working_distance && this.wizardInput.target_spec.target_type === 'size') {
            // Check if Strategy 2 (Periodic + Fresnel) is selected
            if (this.wizardInput.target_spec.use_strategy2) {
                propType = 'periodic_fresnel';
            } else {
                // Determine ASM vs SFR based on target span and DOE size
                const decision = this.determineFiniteDistancePropType();
                propType = decision.propType;
                finiteStrategy = decision.strategy;
            }
        }

        // Update structured params
        this.structuredParams.propagation_type = propType;
        // Ensure working_distance is a scalar (backend may return array)
        let wd = config.working_distance || this.wizardInput.working_distance || null;
        if (Array.isArray(wd)) {
            wd = wd[0];  // Take first element
        }
        this.structuredParams.working_distance = wd;

        // Update target_span for ASM/SFR from computed values or wizard input
        if (propType === 'asm' || propType === 'sfr') {
            // Get target_span from computed values (target_size) or from wizard input
            const targetSize = computed.target_size || config.target_size;
            if (targetSize) {
                this.structuredParams.target_span = targetSize;
            } else if (this.wizardInput.target_spec.target_type === 'size') {
                // For physical size mode, use the target_span from wizard input
                const ts = this.wizardInput.target_spec.target_span;
                this.structuredParams.target_span = Array.isArray(ts) ? Math.max(...ts) : ts;
            }
        } else {
            this.structuredParams.target_span = null;
        }

        if (params.physical) {
            this.structuredParams.wavelength = params.physical.wavelength;
            this.structuredParams.pixel_size = params.physical.pixel_size;
            this.structuredParams.refraction_index = params.physical.refraction_index || 1.62;
        }

        // Calculate doe_pixels from wizard input if not provided
        if (params.doe_pixels) {
            this.structuredParams.doe_pixels = Array.isArray(params.doe_pixels)
                ? params.doe_pixels : [params.doe_pixels, params.doe_pixels];
        } else {
            // Calculate from wizard input
            const doeSize = Math.round(this.wizardInput.device_diameter / this.wizardInput.pixel_size);
            this.structuredParams.doe_pixels = [doeSize, doeSize];
        }

        if (params.simulation_pixels) {
            this.structuredParams.simulation_pixels = Array.isArray(params.simulation_pixels)
                ? params.simulation_pixels : [params.simulation_pixels, params.simulation_pixels];
        }

        if (computed.period_pixels !== undefined) {
            this.structuredParams.period_pixels = computed.period_pixels;
        }

        if (computed.num_periods) {
            this.structuredParams.num_periods = Array.isArray(computed.num_periods)
                ? computed.num_periods : [computed.num_periods, computed.num_periods];
        }

        // Calculate max diffraction angle from pixel size
        // sin(theta_max) = wavelength / (2 * pixel_size)
        const wavelength = params.physical?.wavelength || this.wizardInput.wavelength;
        const pixelSize = params.physical?.pixel_size || this.wizardInput.pixel_size;
        const maxDiffAngle = Math.asin(wavelength / (2 * pixelSize));

        // Update reference values (read-only)
        this.referenceValues = {
            tolerance_limit: computed.tolerance_limit,
            max_diffraction_angle: maxDiffAngle,
            period_meters: computed.period,
            strategy: finiteStrategy || computed.strategy,
            max_pixel_multiplier: computed.max_pixel_multiplier
        };

        // Store original wizard output data
        this.propagatorConfig = config;
        this.computedValues = computed;
        this.warnings = wizardOutput.warnings || [];
        this.metadata = wizardOutput.metadata || {};

        // Store target pattern (used by Preview/Optimization - no wizard call needed)
        this.targetPattern = wizardOutput.target_pattern || null;
    },

    /**
     * Reset state for new optimization
     */
    resetOptimization() {
        this.taskId = null;
        this.progress = null;
        this.lossHistory = [];
        this.isOptimizing = false;
        this.result = null;
        this.visualization = null;
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
    },

    /**
     * Get current wizard input as request body
     * Only contains fields needed for pattern generation
     */
    getWizardRequest() {
        const request = {
            doe_type: this.wizardInput.doe_type,
            wavelength: this.wizardInput.wavelength,
            device_diameter: this.wizardInput.device_diameter,
            pixel_size: this.wizardInput.pixel_size,
            target_spec: { ...this.wizardInput.target_spec }
        };

        if (this.wizardInput.working_distance !== null) {
            request.working_distance = this.wizardInput.working_distance;
        }

        return request;
    },

    /**
     * Get preview request body
     * Uses stored target_pattern (no wizard call needed)
     * All display decisions driven by DOE Settings
     */
    getPreviewRequest() {
        // Compute device_diameter from DOE Settings
        const doePixels = Array.isArray(this.structuredParams.doe_pixels)
            ? this.structuredParams.doe_pixels[0]
            : this.structuredParams.doe_pixels;
        const deviceDiameter = doePixels * this.structuredParams.pixel_size;

        // Ensure target_span_m is a scalar (API expects float, not array)
        let targetSpanM = this.structuredParams.target_span;
        if (Array.isArray(targetSpanM)) {
            targetSpanM = Math.max(...targetSpanM);
        }

        return {
            // Target pattern (already generated by wizard, stored in state)
            target_pattern: this.targetPattern,

            // DOE Settings - drive all display decisions
            wavelength: this.structuredParams.wavelength,
            pixel_size: this.structuredParams.pixel_size,
            device_diameter: deviceDiameter,
            propagation_type: this.structuredParams.propagation_type || 'fft',
            working_distance: this.structuredParams.working_distance,
            target_span_m: targetSpanM || null,
            target_margin: (this.advancedSettings.target_margin || 10) / 100,

            // Data-driven visualization threshold
            scatter_threshold: 1000
        };
    },

    /**
     * Get structured parameters request (for direct params mode)
     */
    getStructuredRequest() {
        return {
            propagation_type: this.structuredParams.propagation_type,
            working_distance: this.structuredParams.working_distance,
            wavelength: this.structuredParams.wavelength,
            pixel_size: this.structuredParams.pixel_size,
            doe_pixels: this.structuredParams.doe_pixels,
            simulation_pixels: this.structuredParams.simulation_pixels,
            period_pixels: this.structuredParams.period_pixels,
            num_periods: this.structuredParams.num_periods,
            advanced: {
                max_resolution: this.advancedSettings.max_resolution,
                target_margin: this.advancedSettings.target_margin / 100,
                progress_interval: this.advancedSettings.progress_interval
            }
        };
    },

    /**
     * Get optimization request body
     * Uses stored target_pattern (no wizard call needed)
     * All optimization driven by DOE Settings
     */
    getOptimizationRequest() {
        // Compute device_diameter from DOE Settings
        const doePixels = Array.isArray(this.structuredParams.doe_pixels)
            ? this.structuredParams.doe_pixels[0]
            : this.structuredParams.doe_pixels;
        const deviceDiameter = doePixels * this.structuredParams.pixel_size;

        return {
            // Target pattern (already generated by wizard, stored in state)
            target_pattern: this.targetPattern,

            // DOE Settings - all physical and simulation params
            wavelength: this.structuredParams.wavelength,
            pixel_size: this.structuredParams.pixel_size,
            device_diameter: deviceDiameter,
            propagation_type: this.structuredParams.propagation_type,
            working_distance: this.structuredParams.working_distance,
            target_span: this.structuredParams.target_span,
            doe_pixels: this.structuredParams.doe_pixels,
            simulation_pixels: this.structuredParams.simulation_pixels,
            period_pixels: this.structuredParams.period_pixels,
            num_periods: this.structuredParams.num_periods,

            // Optimization settings (part of DOE Settings)
            optimization: {
                phase_method: this.optimizationSettings.phase_method,
                phase_lr: this.optimizationSettings.phase_lr,
                phase_iters: this.optimizationSettings.phase_iters,
                loss_type: this.optimizationSettings.loss_type,
                simulation_upsample: this.optimizationSettings.simulation_upsample,
                pixel_multiplier: this.optimizationSettings.pixel_multiplier
            },

            // Advanced settings (part of DOE Settings)
            advanced: {
                max_resolution: this.advancedSettings.max_resolution,
                target_margin: this.advancedSettings.target_margin / 100,
                progress_interval: this.advancedSettings.progress_interval
            }
        };
    },

    /**
     * Update pattern status UI
     * Shows pattern source (wizard or custom) and dimensions
     * @param {string} source - 'wizard', 'custom', or null to clear
     */
    updatePatternStatus(source = null) {
        const statusDiv = document.getElementById('pattern-status');
        const statusText = statusDiv?.querySelector('.status-text');
        const clearBtn = document.getElementById('clear-pattern-btn');
        const hintText = document.getElementById('no-pattern-hint');

        if (!statusDiv) return;

        if (this.targetPattern && source) {
            const h = this.targetPattern.length;
            const w = this.targetPattern[0]?.length || 0;

            statusDiv.style.display = 'flex';
            if (hintText) hintText.style.display = 'none';

            if (source === 'wizard') {
                statusText.textContent = `Wizard pattern (${w}×${h})`;
                clearBtn.style.display = 'none';  // Wizard patterns cleared via new wizard run
            } else if (source === 'custom') {
                statusText.textContent = `Custom pattern (${w}×${h})`;
                clearBtn.style.display = 'inline-block';
            }
        } else {
            statusDiv.style.display = 'none';
            if (hintText) hintText.style.display = 'block';
        }
    }
};

// Make available globally
window.AppState = AppState;
