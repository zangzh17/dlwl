"""
Optimization API Routes.

Handles optimization execution, progress streaming, and result retrieval.
"""

import asyncio
from fastapi import APIRouter, WebSocket, WebSocketDisconnect
from pydantic import BaseModel, Field
from typing import Dict, Any, Optional, List, Tuple

from ..services.task_manager import task_manager, TaskStatus


router = APIRouter(prefix="/api", tags=["optimization"])


class OptimizeRequest(BaseModel):
    """Request schema for starting optimization.

    Uses stored target_pattern from wizard output.
    All optimization driven by DOE Settings.
    """
    # Target pattern (generated by wizard, stored in frontend)
    target_pattern: Optional[List[List[float]]] = Field(None, description="Target pattern from wizard")

    # DOE Settings - all physical and simulation params
    wavelength: float = Field(532e-9, gt=0)
    device_diameter: float = Field(256e-6, gt=0)
    pixel_size: float = Field(1e-6, gt=0)
    propagation_type: str = Field("fft")
    working_distance: Optional[float] = Field(None)
    target_span: Optional[float] = Field(None)
    doe_pixels: Optional[List[int]] = Field(None)
    simulation_pixels: Optional[List[int]] = Field(None)
    period_pixels: Optional[int] = Field(None)
    num_periods: Optional[List[int]] = Field(None)

    # Optimization settings (part of DOE Settings)
    optimization: Optional[Dict[str, Any]] = Field(None)

    # Advanced settings (part of DOE Settings)
    advanced: Optional[Dict[str, Any]] = Field(None)
    # Note: Efficiency calculation derives target_indices from target_pattern
    # No need for wizard-specific metadata


class OptimizeResponse(BaseModel):
    """Response for optimization start."""
    task_id: str
    status: str


class StatusResponse(BaseModel):
    """Response for task status."""
    task_id: str
    status: str
    progress: Optional[Dict[str, Any]] = None
    error: Optional[str] = None


class ResultResponse(BaseModel):
    """Response for optimization result."""
    success: bool
    task_id: str
    status: str
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None


class CancelResponse(BaseModel):
    """Response for cancel request."""
    success: bool
    message: str


class ReevaluateRequest(BaseModel):
    """Request for re-evaluation at different resolution."""
    upsample_factor: int = Field(2, ge=1, le=8)


class ReevaluateResponse(BaseModel):
    """Response for re-evaluation."""
    success: bool
    simulated_intensity: Optional[List[List[float]]] = None
    target_intensity: Optional[List[List[float]]] = None
    phase: Optional[List[List[float]]] = None
    metrics: Optional[Dict[str, Any]] = None
    upsample_factor: Optional[int] = None
    effective_pixel_size: Optional[float] = None  # Pixel size in meters (original / upsample)
    error: Optional[str] = None


@router.post("/optimize", response_model=OptimizeResponse)
async def start_optimization(request: OptimizeRequest) -> OptimizeResponse:
    """Start an optimization task.

    Returns a task_id that can be used to:
    - Query progress via GET /api/status/{task_id}
    - Connect to WebSocket for real-time updates
    - Cancel via POST /api/cancel/{task_id}
    - Get results via GET /api/result/{task_id}
    """
    # Create task
    task_id = task_manager.create_task()

    # Build request data - all from DOE Settings
    request_data = {
        # Target pattern (already generated by wizard, stored in frontend)
        'target_pattern': request.target_pattern,

        # DOE Settings (all physical and simulation params)
        'wavelength': request.wavelength,
        'device_diameter': request.device_diameter,
        'pixel_size': request.pixel_size,
        'propagation_type': request.propagation_type,
    }

    # Optional DOE Settings
    if request.working_distance is not None:
        request_data['working_distance'] = request.working_distance

    if request.target_span is not None:
        request_data['target_span'] = request.target_span

    if request.doe_pixels is not None:
        request_data['doe_pixels'] = request.doe_pixels

    if request.simulation_pixels is not None:
        request_data['simulation_pixels'] = request.simulation_pixels

    if request.period_pixels is not None:
        request_data['period_pixels'] = request.period_pixels

    if request.num_periods is not None:
        request_data['num_periods'] = request.num_periods

    if request.optimization:
        request_data['optimization'] = request.optimization

    if request.advanced:
        request_data['advanced'] = request.advanced

    # Set event loop for async callbacks
    task_manager.set_event_loop(asyncio.get_event_loop())

    # Start optimization in background
    task_manager.start_optimization(task_id, request_data)

    return OptimizeResponse(
        task_id=task_id,
        status="running"
    )


@router.get("/status/{task_id}", response_model=StatusResponse)
async def get_status(task_id: str) -> StatusResponse:
    """Get the current status of an optimization task."""
    task = task_manager.get_task(task_id)

    if not task:
        return StatusResponse(
            task_id=task_id,
            status="not_found",
            error="Task not found"
        )

    return StatusResponse(
        task_id=task_id,
        status=task.status.value,
        progress=task.progress,
        error=task.error
    )


@router.get("/result/{task_id}", response_model=ResultResponse)
async def get_result(task_id: str) -> ResultResponse:
    """Get the result of a completed optimization task."""
    task = task_manager.get_task(task_id)

    if not task:
        return ResultResponse(
            success=False,
            task_id=task_id,
            status="not_found",
            error="Task not found"
        )

    if task.status == TaskStatus.RUNNING:
        return ResultResponse(
            success=False,
            task_id=task_id,
            status=task.status.value,
            error="Task is still running"
        )

    if task.status == TaskStatus.FAILED:
        return ResultResponse(
            success=False,
            task_id=task_id,
            status=task.status.value,
            error=task.error
        )

    if task.status == TaskStatus.CANCELLED:
        return ResultResponse(
            success=False,
            task_id=task_id,
            status=task.status.value,
            error="Task was cancelled"
        )

    print(f"[Result Route] task.result keys: {list(task.result.keys()) if isinstance(task.result, dict) else type(task.result)}")
    if isinstance(task.result, dict) and 'result' in task.result:
        inner = task.result['result']
        print(f"[Result Route] inner result keys: {list(inner.keys()) if isinstance(inner, dict) else type(inner)}")

    return ResultResponse(
        success=True,
        task_id=task_id,
        status=task.status.value,
        result=task.result
    )


@router.post("/cancel/{task_id}", response_model=CancelResponse)
async def cancel_optimization(task_id: str) -> CancelResponse:
    """Cancel a running optimization task."""
    success = task_manager.cancel_task(task_id)

    if success:
        return CancelResponse(
            success=True,
            message="Cancellation requested"
        )
    else:
        return CancelResponse(
            success=False,
            message="Task not found"
        )


@router.post("/reevaluate/{task_id}", response_model=ReevaluateResponse)
async def reevaluate_result(task_id: str, request: ReevaluateRequest) -> ReevaluateResponse:
    """Re-evaluate optimization result at different resolution.

    Takes the optimized phase from a completed task and re-propagates
    at a higher resolution for more accurate metrics.
    """
    task = task_manager.get_task(task_id)

    if not task:
        return ReevaluateResponse(
            success=False,
            error="Task not found"
        )

    if task.status != TaskStatus.COMPLETED:
        return ReevaluateResponse(
            success=False,
            error=f"Task is not completed (status: {task.status.value})"
        )

    try:
        # Get the stored phase and wizard output from the task
        # Result structure: {success: bool, result: {phase: [...], ...}}
        result = task.result
        print(f"[Reevaluate Route] Got result, type={type(result)}")
        inner_result = result.get('result', {}) if result else {}
        if not inner_result or 'phase' not in inner_result:
            return ReevaluateResponse(
                success=False,
                error="No phase data in result"
            )
        print(f"[Reevaluate Route] Phase found, calling reevaluate_at_resolution")

        # Re-evaluate at higher resolution using task manager
        reevaluated = task_manager.reevaluate_at_resolution(
            task_id,
            request.upsample_factor
        )
        print(f"[Reevaluate Route] Got result: {reevaluated is not None}")

        if reevaluated is None:
            return ReevaluateResponse(
                success=False,
                error="Re-evaluation failed"
            )

        # Debug logging
        phase = reevaluated.get('phase')
        simulated = reevaluated.get('simulated_intensity')
        eff_pixel = reevaluated.get('effective_pixel_size')
        print(f"[Reevaluate Route] phase type={type(phase)}, phase[0] len={len(phase[0]) if phase else 0}")
        print(f"[Reevaluate Route] simulated type={type(simulated)}, simulated[0] len={len(simulated[0]) if simulated else 0}")
        print(f"[Reevaluate Route] effective_pixel_size={eff_pixel}")

        return ReevaluateResponse(
            success=True,
            simulated_intensity=reevaluated.get('simulated_intensity'),
            target_intensity=reevaluated.get('target_intensity'),
            phase=reevaluated.get('phase'),
            metrics=reevaluated.get('metrics'),
            upsample_factor=reevaluated.get('upsample_factor'),
            effective_pixel_size=reevaluated.get('effective_pixel_size')
        )

    except Exception as e:
        import traceback
        traceback.print_exc()
        return ReevaluateResponse(
            success=False,
            error=f"{type(e).__name__}: {str(e)}"
        )


# WebSocket endpoint for real-time progress
@router.websocket("/ws/optimize/{task_id}")
async def websocket_progress(websocket: WebSocket, task_id: str):
    """WebSocket endpoint for real-time progress updates.

    Connect to receive progress messages:
    {
        "type": "progress",
        "stage": "phase",
        "current_iter": 5000,
        "total_iters": 10000,
        "current_loss": 0.00123,
        "best_loss": 0.00098,
        "progress_percent": 50.0,
        "estimated_remaining_seconds": 45.2
    }

    Or completion message:
    {
        "type": "complete",
        "status": "completed" | "cancelled" | "failed"
    }
    """
    await websocket.accept()

    task = task_manager.get_task(task_id)
    if not task:
        await websocket.send_json({"type": "error", "message": "Task not found"})
        await websocket.close(code=4004)
        return

    # Add to client list for broadcasts
    task_manager.add_websocket_client(task_id, websocket)

    try:
        # Send current progress if available
        if task.progress:
            await websocket.send_json({"type": "progress", **task.progress})

        # If already completed, send completion message
        if task.status in (TaskStatus.COMPLETED, TaskStatus.CANCELLED, TaskStatus.FAILED):
            await websocket.send_json({"type": "complete", "status": task.status.value})
            return

        # Keep connection open until task completes
        while True:
            try:
                # Wait for messages or timeout
                # This allows the client to send ping/pong or close
                await asyncio.wait_for(
                    websocket.receive_text(),
                    timeout=30.0
                )
            except asyncio.TimeoutError:
                # Check if task is done
                if task.status in (TaskStatus.COMPLETED, TaskStatus.CANCELLED, TaskStatus.FAILED):
                    break
                # Send ping to keep connection alive
                try:
                    await websocket.send_json({"type": "ping"})
                except Exception:
                    break

    except WebSocketDisconnect:
        pass
    except Exception:
        pass
    finally:
        task_manager.remove_websocket_client(task_id, websocket)
