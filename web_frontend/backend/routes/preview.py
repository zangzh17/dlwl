"""
Preview API Routes.

Handles preview generation for geometry diagrams and target patterns.
"""

from fastapi import APIRouter
from pydantic import BaseModel, Field, field_validator
from typing import Dict, Any, Optional, List, Tuple, Union
import numpy as np

from doe_optimizer import generate_params

from ..services.preview_service import (
    generate_geometry_svg,
    generate_target_scatter,
    generate_target_heatmap,
)


router = APIRouter(prefix="/api", tags=["preview"])


def pad_target_with_margin(target: np.ndarray, margin: float) -> np.ndarray:
    """Pad target pattern with zeros to represent margin area.

    Args:
        target: Original target pattern (2D array)
        margin: Margin as decimal (e.g., 0.1 for 10%)

    Returns:
        Padded target pattern with zeros around the edges
    """
    if margin <= 0:
        return target

    h, w = target.shape
    # Total size = original * (1 + margin)
    # Padding per side = original * margin / 2
    pad_h = int(h * margin / 2)
    pad_w = int(w * margin / 2)

    # Pad with zeros
    padded = np.pad(target, ((pad_h, pad_h), (pad_w, pad_w)), mode='constant', constant_values=0)
    return padded


class PreviewRequest(BaseModel):
    """Request schema for preview generation.

    Preview is driven entirely by DOE Settings.
    Uses stored target_pattern from wizard output (no wizard call needed).
    Visualization decisions are data-driven (threshold-based), not type-based.
    """
    # Target pattern (generated by wizard, stored in frontend)
    target_pattern: Optional[List[List[float]]] = Field(None, description="Target pattern from wizard")

    # DOE Settings - these drive ALL preview display decisions
    wavelength: float = Field(532e-9, gt=0)
    device_diameter: float = Field(256e-6, gt=0)
    pixel_size: float = Field(1e-6, gt=0)
    propagation_type: str = Field("fft", description="Propagation type from DOE Settings")
    working_distance: Optional[float] = Field(None)
    target_span_m: Optional[Union[float, List[float]]] = Field(None, description="Target Span from DOE Settings (meters)")
    target_margin: float = Field(0.1, description="Target Margin from DOE Settings (decimal)")

    # Threshold for scatter vs heatmap visualization (data-driven)
    scatter_threshold: int = Field(1000, description="Use scatter plot if non-zero orders < this threshold")

    @field_validator('target_span_m', mode='before')
    @classmethod
    def normalize_target_span(cls, v):
        """Convert array to scalar (use max value)."""
        if v is None:
            return None
        if isinstance(v, list):
            return max(v) if v else None
        return v

    @field_validator('working_distance', mode='before')
    @classmethod
    def normalize_working_distance(cls, v):
        """Convert string/array to float, handle empty strings."""
        print(f"[validator] working_distance raw value: {v!r} (type: {type(v).__name__})")
        if v is None or v == '' or v == 'null':
            return None
        if isinstance(v, list):
            # Handle array - take first element or max
            if not v:
                return None
            v = v[0] if len(v) == 1 else max(v)
        if isinstance(v, str):
            try:
                return float(v)
            except ValueError:
                return None
        if isinstance(v, (int, float)):
            return float(v)
        # Handle unexpected types
        return None


class PreviewResponse(BaseModel):
    """Response schema for preview."""
    success: bool
    geometry_svg: Optional[str] = None
    target_scatter: Optional[Dict[str, Any]] = None
    target_heatmap: Optional[Dict[str, Any]] = None
    error: Optional[str] = None


@router.post("/preview", response_model=PreviewResponse)
async def generate_preview(request: PreviewRequest) -> PreviewResponse:
    """Generate preview data for visualization.

    Uses stored target_pattern from frontend (no wizard call).
    Visualization decisions are DATA-DRIVEN, not type-based:
    - Scatter plot: if non-zero orders < scatter_threshold (default 1000)
    - Heatmap: if many non-zero pixels (continuous pattern)
    """
    try:
        # Debug: Log request details
        print(f"[preview] propagation_type: {request.propagation_type}")
        print(f"[preview] working_distance: {request.working_distance}")
        print(f"[preview] target_span_m: {request.target_span_m} (type: {type(request.target_span_m).__name__})")
        if request.target_pattern:
            print(f"[preview] target_pattern shape: {len(request.target_pattern)}x{len(request.target_pattern[0])}")
        # Determine target_type from propagation and working_distance
        # For finite distance (ASM/SFR with working_distance), use physical coordinates
        # For infinite distance (FFT), use angular coordinates
        target_type = 'angle'
        target_span = [0.1, 0.1]  # Default angular span

        if request.propagation_type in ('asm', 'sfr') and request.working_distance:
            target_type = 'size'
            if request.target_span_m:
                target_span = [request.target_span_m, request.target_span_m]

        # Generate geometry SVG using DOE Settings only
        geometry_svg = generate_geometry_svg(
            device_diameter=request.device_diameter,
            working_distance=request.working_distance,
            target_span=tuple(target_span),
            target_type=target_type,
            wavelength=request.wavelength,
            doe_shape='square'
        )

        target_scatter = None
        target_heatmap = None

        # Use stored target pattern (no wizard call needed)
        if request.target_pattern is not None:
            target_np = np.array(request.target_pattern)
            target_np = target_np ** 2  # Convert to intensity

            # Count non-zero elements for data-driven visualization decision
            non_zero_count = np.count_nonzero(target_np > 1e-6)

            # Get propagation type from DOE Settings
            prop_type = request.propagation_type

            # DATA-DRIVEN visualization decision:
            # Use scatter plot if we have discrete orders (few non-zero points)
            # Use heatmap if we have continuous pattern (many non-zero points)
            use_scatter = non_zero_count < request.scatter_threshold

            if use_scatter:
                # Discrete orders (few non-zero points)
                # Show heatmap with appropriate coordinates based on propagation type
                if prop_type in ('sfr', 'asm') and request.working_distance and request.target_span_m:
                    # Physical coordinates
                    target_size_with_margin = request.target_span_m * (1.0 + request.target_margin)
                    target_with_margin = pad_target_with_margin(target_np, request.target_margin)
                    target_scatter = generate_target_heatmap(
                        target_with_margin, "Target Pattern (Physical)",
                        coordinate_type='physical',
                        physical_extent=(target_size_with_margin, target_size_with_margin)
                    )
                else:
                    # Angular coordinates (FFT) - resample to uniform angle space (方案C)
                    fft_angular_span = request.wavelength / request.pixel_size
                    target_scatter = generate_target_heatmap(
                        target_np, "Target Pattern (Angular)",
                        coordinate_type='angle',
                        angle_extent=(fft_angular_span, fft_angular_span),
                        wavelength=request.wavelength,
                        pixel_size=request.pixel_size,
                        resample_angle=True
                    )

                # Intensity view with pixel coordinates
                target_heatmap = generate_target_heatmap(
                    target_np, "Target Intensity (Pixels)",
                    coordinate_type='pixels'
                )
            else:
                # Continuous pattern (many non-zero points) - use heatmap with coordinates
                if prop_type in ('sfr', 'asm') and request.working_distance:
                    # Physical size mode - show mm coordinates
                    if request.target_span_m:
                        # Pad target pattern with zeros to show margin area
                        target_with_margin = pad_target_with_margin(target_np, request.target_margin)
                        target_size_with_margin = request.target_span_m * (1.0 + request.target_margin)
                        target_scatter = generate_target_heatmap(
                            target_with_margin, "Target Pattern (Physical)",
                            coordinate_type='physical',
                            physical_extent=(target_size_with_margin, target_size_with_margin)
                        )
                        target_heatmap = generate_target_heatmap(
                            target_with_margin, "Target Intensity (Pixels)",
                            coordinate_type='pixels'
                        )
                    else:
                        target_scatter = generate_target_heatmap(target_np, "Target Pattern")
                        target_heatmap = generate_target_heatmap(
                            target_np, "Target Intensity (Pixels)",
                            coordinate_type='pixels'
                        )
                else:
                    # FFT mode - show angular coordinates with resampling (方案C)
                    fft_angular_span = request.wavelength / request.pixel_size
                    target_scatter = generate_target_heatmap(
                        target_np, "Target Pattern (Angular)",
                        coordinate_type='angle',
                        angle_extent=(fft_angular_span, fft_angular_span),
                        wavelength=request.wavelength,
                        pixel_size=request.pixel_size,
                        resample_angle=True
                    )
                    target_heatmap = generate_target_heatmap(
                        target_np, "Target Intensity (Pixels)",
                        coordinate_type='pixels'
                    )

        return PreviewResponse(
            success=True,
            geometry_svg=geometry_svg,
            target_scatter=target_scatter,
            target_heatmap=target_heatmap
        )

    except Exception as e:
        import traceback
        traceback.print_exc()
        return PreviewResponse(
            success=False,
            error=str(e)
        )
