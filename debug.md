# True Wizard Decoupling Architecture (v3.2)

## Design Principle

**Wizard runs ONCE to generate DOE Settings + Target Pattern**. All other modules use stored data, never calling wizard again.

```
[Wizard Input]
    │ (doe_type, target_spec, wavelength, device_diameter, pixel_size)
    │
    ▼ (ONE-TIME call to /api/wizard)
[Wizard] ──────────────────────────────────────────────────┐
    │ Returns:                                              │
    │  - structured_params (DOE Settings)                  │
    │  - target_pattern (2D array, stored in frontend)     │
    │  - computed_values, warnings, metadata               │
    ▼                                                       │
[DOE Settings + Target Pattern] ◄──────────────────────────┘
    │ (stored in frontend AppState)
    │
    ├──────────────────┬─────────────────┬──────────────────┐
    │                  │                 │                  │
    ▼                  ▼                 ▼                  ▼
[Reference Values]  [Preview]      [Optimization]     [Analysis]
(DOE Settings only) (target_pattern  (target_pattern   (DOE Settings)
                    + DOE Settings)   + DOE Settings)
```

## Key Principle: No Wizard Calls After Initial Generation

- **Wizard**: Called ONCE when user clicks "Generate DOE Settings"
- **Preview**: Uses stored `target_pattern` from state, no wizard call
- **Optimization**: Uses stored `target_pattern` from state, no wizard call
- **Re-evaluation**: Uses stored `target_pattern` from state, no wizard call

## Data Storage

### Frontend (state.js)

```javascript
AppState = {
    // Target pattern (generated by wizard, stored here)
    targetPattern: null,  // 2D array [[...], [...]]

    // DOE Settings (editable after wizard generates them)
    structuredParams: {
        propagation_type: 'fft',
        working_distance: null,
        target_span: null,
        wavelength: 532e-9,
        pixel_size: 1e-6,
        doe_pixels: [256, 256],
        simulation_pixels: [21, 21],
        period_pixels: 21,
        num_periods: [12, 12]
    },

    // Optimization settings
    optimizationSettings: {
        phase_method: 'SGD',
        phase_lr: 3e-9,
        phase_iters: 1000,
        loss_type: 'L2',
        simulation_upsample: 1,
        pixel_multiplier: 1
    },

    // Advanced settings
    advancedSettings: {
        max_resolution: 2000,
        target_margin: 10,  // percent
        progress_interval: 50
    }
}
```

## Request Structures

### Preview Request (POST /api/preview)

```javascript
{
    // Target pattern (stored, not regenerated)
    target_pattern: [[...], [...]],

    // DOE Settings (all from structuredParams)
    wavelength: 532e-9,
    pixel_size: 1e-6,
    device_diameter: 256e-6,
    propagation_type: "fft",
    working_distance: null,
    target_span_m: null,
    target_margin: 0.1,
    scatter_threshold: 1000
}
```

### Optimization Request (POST /api/optimize)

```javascript
{
    // Target pattern (stored, not regenerated)
    target_pattern: [[...], [...]],

    // DOE Settings
    wavelength: 532e-9,
    pixel_size: 1e-6,
    device_diameter: 256e-6,
    propagation_type: "fft",
    working_distance: null,
    target_span: null,
    doe_pixels: [256, 256],
    simulation_pixels: [21, 21],
    period_pixels: 21,
    num_periods: [12, 12],

    // Optimization settings
    optimization: {
        phase_method: "SGD",
        phase_lr: 3e-9,
        phase_iters: 1000,
        loss_type: "L2",
        simulation_upsample: 1,
        pixel_multiplier: 1
    },

    // Advanced settings
    advanced: {
        max_resolution: 2000,
        target_margin: 0.1,
        progress_interval: 50
    }
}
```

## Backend Implementation

### preview.py

- **No wizard import or call**
- Accepts `target_pattern` directly from request
- Uses DOE Settings for coordinate display
- Data-driven visualization: `non_zero_count < scatter_threshold` -> scatter plot

### runner.py

```python
def run(self, request, ...):
    if request.user_input.get('target_pattern') is not None:
        # Target pattern provided directly (stored from previous wizard call)
        # Build minimal wizard output without calling wizard
        wizard_output = self._create_wizard_output_from_target_pattern(
            request.user_input
        )
    else:
        # Normal flow: use wizard to generate params
        wizard_output = generate_params(request.user_input, ...)
```

### task_manager.py

- Re-evaluation builds propagator config directly from DOE Settings
- Uses stored `target_pattern` from request_data
- No wizard call for re-propagation

## Data-Driven Visualization

Visualization decisions based on data characteristics, not type labels:

```python
non_zero_count = np.count_nonzero(target_np > 1e-6)
if non_zero_count < scatter_threshold:  # default: 1000
    # Discrete orders -> heatmap with coordinate labels
    use_heatmap_with_coordinates()
else:
    # Continuous pattern -> heatmap
    use_heatmap()
```

## Removed/Unused Parameters

- `refraction_index`: Backend uses default 1.62
- `device_shape`: Not used in optimization
- `doe_type` in visualization decisions: Replaced by data-driven threshold

## Key Files

**Frontend:**
- `state.js`: `targetPattern` storage, `getPreviewRequest()`, `getOptimizationRequest()`
- `params.js`: `renderReferenceValues()` - uses only DOE Settings

**Backend:**
- `wizard.py`: Returns `target_pattern` in response
- `preview.py`: Accepts `target_pattern`, no wizard call
- `optimize.py`: Accepts `target_pattern`, no wizard call
- `runner.py`: `_create_wizard_output_from_target_pattern()` bypasses wizard
- `task_manager.py`: Re-evaluation uses stored target_pattern

## Benefits

1. **Performance**: No redundant wizard calls for Preview/Optimization
2. **Consistency**: Same target pattern used across all operations
3. **Flexibility**: Users can edit DOE Settings after wizard generation
4. **Simplicity**: Clear data flow, no hidden wizard dependencies
